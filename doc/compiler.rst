Компилятор Lisp
==============================

Виртуальная машина
------------------------------

Точка входа виртуальной машины - функция vm-run, принимающая на вход список инструкций и выполняющая каждую из них последовательно.

Список регистров
------------------------------

- ACC - хранит результат последней операции.
- GLOBALS-MEM - содержит данные для глобальных переменных.
- STACK - стэк общего назначения.
- CALL-STACK - стэк вызова, содержащий адреса возврата функций.

Список инструкций
------------------------------

- LDA expr - поместить expr в регистр ACC.
- JMP label - безусловный переход на метку label.
- JNT label - если ACC != t, то переход на метку label.
- GLOBAL-SET i - устанавливает глобальной переменной из регистра GLOBALS-MEM с индексом i значение регистра ACC.
- GLOBAL-GET i - устанавливает регистру ACC значение глобальной переменной из регистра GLOBALS-MEM с индексом i.
- PUSH - добавляет значение регистра ACC в стэк.
- PEEK i - загружает в ACC значение i-го элемента стэка, начиная с верхушки (i = 0 - самый верхний элемент стэка, i = 1 - следующий и т.д.). Не изменяет стэк.
- CALL addr - добавляет адрес следующей инструкции в стэк вызова и производит переход на адрес addr.
- RET n - производит переход на адрес из верхушки стэка вызова, удаляет этот адрес из стэка вызова и удаляет n элементов из верхушки стэка (для освобождения параметров функции).
- HLT - останавливает выполнение текущей программы.

Функции
------------------------------

::
   
   (vm-run program)
     program - массив инструкций (пар опкодов и операндов).
     Последовательно выполняет каждую инструкцию.
     Возвращает содержимое регистра ACC.

::
   
   (compile expr)
     expr - S-выражение.
     Создаёт список инструкций для вычисления S-выражения expr
     на виртуальной машине с помощью функции vm-run.
     Примеры вычисления атома:
       5 -> ((lda 5))
       t -> ((lda t))
       a -> ((global-get 0)), если существует
              переменная с символом "A" и с индексом
              0 в регистре GLOBALS-MEM, иначе:
            "Compilation error: No such global
            variable: A"

::
   
   (compile-progn lst)
     lst - список S-выражений (тело progn).
     Вычисляет progn выражение - последовательно генерирует инструкции
     для каждого элемента тела progn из списка lst.
     Пример:
       (progn 1 2 3) -> ((lda 1) (lda 2) (lda 3))

::
   
   (compile-if if-body)
     if-body - тело if-выражения (условие, ветка по "да" и ветка по "нет").
     Генерирует инструкции, вычисляющие if-выражение.
     Пример:
       (if (t1 t2 t3) (a1 a2 a3) (b1 b2 b3)) ->
       (
          t1 t2 t3
          (jnt label-false)
          a1 a2 a3
          (jmp label-after)
          label-false
          b1 b2 b3
          label-after
       )

::

   (compile-setq setq-body)
     setq-body - список аргументов (символ и S-выражение).
     Генерирует инструкции, вычисляющие setq-выражение.
     Примеры:
       (setq x (a1 a2 a3)) ->
       (
         a1 a2 a3
         (global-set 0)
         (lda x)
       )

::
   
   (compile-lambda body)
     body - аргументы и тело лямбда-функции.
     Компилирует лямбда-выражение.
     Примеры:
       ((lambda (a b) a) 5 10) ->
       (
         (lda 10) ; 0
         (push)   ; 1
         (lda 5)  ; 2
         (push)   ; 3
         (call 6) ; 4
         (hlt)    ; 5
         (peek 0) ; 6 - (lambda (a b) a)
         (ret 2)  ; 7
       )
     
       ((lambda (x) ((lambda (y) x) 10)) 5) ->
       (
         (lda 5)  ; 0
         (push)   ; 1
         (call 4) ; 2
         (hlt)    ; 3
         (lda 10) ; 4 - (lambda (x) ...)
         (push)   ; 5
         (call 8) ; 6
         (ret 1)  ; 7
         (peek 1) ; 8 - (lambda (y) x)
         (ret 1)  ; 9
       )
